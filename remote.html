<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>VISTA Remote</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&display=swap");

      :root {
        --bg-1: #0b1220;
        --bg-2: #111827;
        --accent: #38bdf8;
        --accent-2: #22c55e;
        --card: rgba(255, 255, 255, 0.08);
        --border: rgba(148, 163, 184, 0.3);
        --text: #f8fafc;
        --muted: #cbd5f5;
        --danger: #f43f5e;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Space Grotesk", "Segoe UI", sans-serif;
        background: radial-gradient(circle at top, #1e40af 0%, #0f172a 55%, #020617 100%);
        color: var(--text);
        min-height: 100vh;
      }

      .container {
        max-width: 620px;
        margin: 0 auto;
        padding: 18px 16px 32px;
        display: grid;
        gap: 16px;
      }

      .header {
        display: grid;
        gap: 8px;
        padding: 16px;
        border-radius: 16px;
        background: var(--card);
        border: 1px solid var(--border);
        backdrop-filter: blur(8px);
      }

      .title {
        font-size: 22px;
        font-weight: 700;
        letter-spacing: 0.4px;
      }

      .status {
        display: flex;
        flex-wrap: wrap;
        gap: 8px 12px;
        font-size: 14px;
        color: var(--muted);
        align-items: center;
      }

      .pill {
        padding: 4px 10px;
        border-radius: 999px;
        background: rgba(56, 189, 248, 0.18);
        color: var(--text);
        font-size: 12px;
      }

      .chat-card {
        padding: 16px;
        border-radius: 18px;
        background: var(--card);
        border: 1px solid var(--border);
        display: grid;
        gap: 12px;
        min-height: 70vh;
      }

      .chat-log {
        display: grid;
        gap: 10px;
        overflow-y: auto;
        padding-right: 6px;
        max-height: 56vh;
      }

      .msg {
        max-width: 85%;
        padding: 10px 12px;
        border-radius: 14px;
        background: rgba(15, 23, 42, 0.55);
        border: 1px solid rgba(148, 163, 184, 0.2);
        font-size: 14px;
        line-height: 1.45;
        word-break: break-word;
        overflow-wrap: anywhere;
        white-space: pre-wrap;
      }

      .msg.user {
        justify-self: end;
        background: rgba(56, 189, 248, 0.2);
        border-color: rgba(56, 189, 248, 0.4);
      }

      .msg.agent {
        justify-self: start;
      }

      .chat-input {
        display: grid;
        gap: 10px;
      }

      .chat-row {
        display: grid;
        grid-template-columns: auto 1fr auto;
        gap: 10px;
        align-items: center;
      }

      input {
        width: 100%;
        padding: 12px 14px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: rgba(15, 23, 42, 0.6);
        color: var(--text);
        font-size: 14px;
      }

      button {
        padding: 12px 14px;
        border-radius: 12px;
        border: none;
        background: var(--accent);
        color: #0f172a;
        font-weight: 700;
        cursor: pointer;
        transition: transform 0.12s ease, box-shadow 0.2s ease;
        white-space: nowrap;
      }

      button.secondary {
        background: rgba(148, 163, 184, 0.2);
        color: var(--text);
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        box-shadow: none;
      }

      button:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 10px 24px rgba(56, 189, 248, 0.35);
      }

      .chat-status {
        font-size: 12px;
        color: var(--muted);
        text-align: right;
      }

      .notice {
        font-size: 12px;
        color: var(--muted);
      }

      @media (max-width: 560px) {
        .chat-row {
          grid-template-columns: 1fr;
        }

        button {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <main class="container">
      <div class="header">
        <div class="title">VISTA Remote</div>
        <div class="status">
          <span class="pill" id="conn-pill">Connecting...</span>
          <span>Session: <span id="session-id">—</span></span>
        </div>
        <div class="notice" id="notice">Chat with the agent to control the presenter.</div>
      </div>

      <section class="chat-card">
        <div class="chat-log" id="chat-log"></div>
        <div class="chat-input">
          <div class="chat-row">
            <button class="secondary" id="chat-mic" type="button">Mic</button>
            <input id="chat-input" type="text" placeholder="Ask the agent to search, generate, refine..." />
            <button id="chat-send" type="button">Send</button>
          </div>
          <div class="chat-status" id="chat-status">Ready.</div>
        </div>
      </section>
    </main>

    <script>
      const API_BASE = "https://vista-backend-1-6r3t.onrender.com";

      const sessionIdEl = document.getElementById("session-id");
      const connPill = document.getElementById("conn-pill");
      const notice = document.getElementById("notice");
      const chatLog = document.getElementById("chat-log");
      const chatInput = document.getElementById("chat-input");
      const chatSend = document.getElementById("chat-send");
      const chatMic = document.getElementById("chat-mic");
      const chatStatus = document.getElementById("chat-status");

      let sessionId = null;
      let messages = [];
      let recorder = null;
      let recording = false;
      let recordingChunks = [];

      function setConnection(ok, text) {
        connPill.textContent = text;
        connPill.style.background = ok
          ? "rgba(34, 197, 94, 0.2)"
          : "rgba(244, 63, 94, 0.2)";
      }

      function setStatus(text) {
        chatStatus.textContent = text;
      }

      function sanitize(text) {
        if (!text) return "";
        let cleaned = text.replace(/!\[[^\]]*?\]\([^)]+?\)/g, "");
        cleaned = cleaned.replace(/\[[^\]]*?\]\((https?:\/\/[^)]+?)\)/g, "");
        cleaned = cleaned.replace(/https?:\/\/\S+/g, "");
        cleaned = cleaned.replace(/\S+\/\S*(crop=|ixid=|ixlib=|fm=|fit=)\S*/gi, "");
        cleaned = cleaned
          .split("\n")
          .map((line) => line.trim())
          .filter((line) => line && !/^[\d\-•]+\.?$/.test(line));
        cleaned = cleaned.join("\n").replace(/\s{2,}/g, " ").trim();
        return cleaned || "Got it.";
      }

      function appendMessage(role, text) {
        const cleaned = sanitize(text || "");
        if (!cleaned) return;
        messages.push({ role, content: cleaned });
        const bubble = document.createElement("div");
        bubble.className = `msg ${role === "user" ? "user" : "agent"}`;
        bubble.textContent = cleaned;
        chatLog.appendChild(bubble);
        chatLog.scrollTop = chatLog.scrollHeight;
      }

      function buildSummary() {
        return messages.slice(-6).map((item) => `${item.role}: ${item.content}`).join(" | ");
      }

      async function sendCommand(type, payload = {}) {
        if (!sessionId) {
          setStatus("No session. Scan the QR code on the presenter.");
          return;
        }
        try {
          const res = await fetch(`${API_BASE}/api/cmd`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              session: sessionId,
              command: { type, ...payload }
            })
          });
          const data = await res.json();
          if (!res.ok) {
            setConnection(false, "Disconnected");
            setStatus(data.error || "Send failed");
            return;
          }
          setConnection(true, "Connected");
          setStatus("Sent ✓");
        } catch (err) {
          setConnection(false, "Reconnecting...");
          setStatus("Network error");
        }
      }

      function dispatchTool(tool, args) {
        if (tool === "search_library") {
          sendCommand("theme", {
            keyword: args.query || "",
            mode: args.source || "unsplash",
            ratio: args.ratio || "1:1"
          });
        }
        if (tool === "generate_ai") {
          sendCommand("ai_generate", {
            keyword: args.prompt || "",
            mode: "flux",
            count: args.count || 1,
            size: args.aspect_ratio || "1:1"
          });
        }
        if (tool === "refine_image") {
          sendCommand("refine", { prompt: args.prompt || "" });
        }
      }

      async function sendChat() {
        const raw = chatInput.value.trim();
        if (!raw) return;
        chatInput.value = "";
        appendMessage("user", raw);
        setStatus("Thinking...");
        chatSend.disabled = true;

        try {
          const res = await fetch(`${API_BASE}/api/agent`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              message: raw,
              summary: buildSummary(),
              state: { remote: true }
            })
          });
          const data = await res.json();
          if (!res.ok) {
            throw new Error(data.error || "Agent failed");
          }

          if (data.tool) {
            dispatchTool(data.tool, data.tool_args || {});
            appendMessage("assistant", "Done. Presenter updated.");
          } else if (data.reply) {
            appendMessage("assistant", data.reply);
          }
          setStatus("Ready.");
        } catch (err) {
          appendMessage("assistant", `Error: ${err.message}`);
          setStatus("Error");
        } finally {
          chatSend.disabled = false;
        }
      }

      async function startRecording() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          chatMic.disabled = true;
          chatMic.title = "Voice input not supported.";
          return;
        }
        if (recording) return;
        recordingChunks = [];
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          recorder = new MediaRecorder(stream);
          recorder.ondataavailable = (event) => {
            if (event.data && event.data.size > 0) {
              recordingChunks.push(event.data);
            }
          };
          recorder.onstop = async () => {
            stream.getTracks().forEach((track) => track.stop());
            const blob = new Blob(recordingChunks, { type: recorder.mimeType || "audio/webm" });
            const base64 = await blobToBase64(blob);
            await transcribeAudio(base64, blob.type);
          };
          recorder.start();
          recording = true;
          chatMic.classList.add("active");
          chatMic.textContent = "Stop";
          setStatus("Recording...");
        } catch (err) {
          setStatus("Mic error.");
        }
      }

      function stopRecording() {
        if (!recorder || !recording) return;
        recorder.stop();
        recording = false;
        chatMic.classList.remove("active");
        chatMic.textContent = "Mic";
        setStatus("Transcribing...");
      }

      function blobToBase64(blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => {
            const result = reader.result || "";
            const base64 = result.toString().split(",")[1] || "";
            resolve(base64);
          };
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      }

      async function transcribeAudio(base64, mime) {
        try {
          const res = await fetch(`${API_BASE}/api/transcribe`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ audio: base64, mime })
          });
          const data = await res.json();
          if (!res.ok) {
            throw new Error(data.error || "Transcription failed");
          }
          if (data.text) {
            chatInput.value = data.text;
            await sendChat();
          } else {
            setStatus("No speech detected.");
          }
        } catch (err) {
          setStatus(`Mic error: ${err.message}`);
        }
      }

      function initSession() {
        const params = new URLSearchParams(window.location.search);
        const fromUrl = params.get("session");
        const stored = localStorage.getItem("vista_session_id");
        sessionId = fromUrl || stored || "";
        if (sessionId) {
          localStorage.setItem("vista_session_id", sessionId);
          sessionIdEl.textContent = sessionId;
          setConnection(true, "Connected");
          notice.textContent = "Ready to control the presenter.";
        } else {
          sessionIdEl.textContent = "—";
          setConnection(false, "No session");
          notice.textContent = "Scan the QR code on the presenter screen.";
        }
      }

      chatSend.addEventListener("click", sendChat);
      chatInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendChat();
        }
      });
      chatMic.addEventListener("click", () => {
        if (recording) {
          stopRecording();
        } else {
          startRecording();
        }
      });

      initSession();
    </script>
  </body>
</html>
