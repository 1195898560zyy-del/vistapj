<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>VISTA — Image Library + AI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f7fb;
      color: #333;
      margin: 0;
      padding: 24px;
      text-align: center;
    }

    h1 {
      margin: 0 0 10px;
      font-size: 32px;
      letter-spacing: 1px;
    }

    .view-toggle {
      position: fixed;
      top: 16px;
      right: 16px;
      display: flex;
      gap: 8px;
      z-index: 5;
    }

    .view-toggle button {
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid #cbd5e1;
      background: rgba(255, 255, 255, 0.9);
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
    }

    .view-toggle button.active {
      background: #0f172a;
      color: #f8fafc;
      border-color: #0f172a;
    }

    .weather {
      position: fixed;
      inset: 0;
      border-radius: 0;
      border: none;
      overflow: hidden;
      min-height: 100vh;
      box-shadow: none;
      z-index: 1;
    }

    .weather::after {
      content: "";
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.12);
      pointer-events: none;
    }

    .weather-bg {
      position: absolute;
      inset: 0;
      background-size: cover;
      background-position: center;
      transform: scale(1.01);
    }

    .weather-bg-layer {
      position: absolute;
      inset: 0;
      background-size: cover;
      background-position: center;
      opacity: 0;
      transition: opacity 1.2s ease;
      animation: slowZoom 18s ease-in-out infinite;
    }

    .weather-bg-layer.is-active {
      opacity: 1;
    }

    @keyframes slowZoom {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .weather-content {
      position: relative;
      z-index: 1;
      padding: 28px 32px;
      color: #f8fafc;
      text-align: left;
      display: grid;
      gap: 8px;
      text-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
    }

    .weather-title {
      font-size: 12px;
      letter-spacing: 1px;
      text-transform: uppercase;
      opacity: 0.8;
    }

    .weather-main {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      gap: 12px;
    }

    .weather-temp {
      font-size: 56px;
      font-weight: 700;
    }

    .weather-meta {
      display: grid;
      gap: 4px;
      font-size: 14px;
    }

    .weather-extra {
      display: flex;
      gap: 14px;
      font-size: 12px;
      opacity: 0.85;
      flex-wrap: wrap;
    }

    .view-hidden {
      display: none;
    }

    .app-view {
      position: relative;
      z-index: 2;
    }

    .bar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      align-items: center;
      margin: 10px auto 18px;
    }

    .control-panels {
      width: 90%;
      max-width: 1000px;
      margin: 10px auto 18px;
      display: grid;
      gap: 12px;
    }

    .panel {
      padding: 12px 14px;
      border-radius: 16px;
      background: #ffffff;
      border: 1px solid #e2e8f0;
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.06);
      text-align: left;
      display: grid;
      gap: 10px;
    }

    .panel-title {
      font-size: 14px;
      font-weight: 700;
      color: #0f172a;
      text-transform: uppercase;
      letter-spacing: 0.6px;
    }

    .panel-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .panel-row input {
      flex: 1;
      min-width: 220px;
    }

    input, select, button {
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid #d0d7e2;
      font-size: 14px;
      background: #fff;
      outline: none;
    }

    input {
      min-width: 230px;
    }

    select {
      min-width: 150px;
    }

    #ai-count {
      min-width: 70px;
      max-width: 80px;
      text-align: center;
    }

    button {
      cursor: pointer;
      transition: background 0.15s, transform 0.1s, box-shadow 0.15s;
    }

    button.primary {
      background-color: #007bff;
      color: white;
      border-color: #007bff;
      box-shadow: 0 4px 10px rgba(0, 123, 255, 0.25);
    }

    button.primary:hover {
      background-color: #0056b3;
      transform: translateY(-1px);
      box-shadow: 0 6px 14px rgba(0, 123, 255, 0.35);
    }

    #status {
      min-height: 22px;
      font-size: 14px;
      color: #666;
      margin-bottom: 8px;
    }

    #gallery {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 520px;
      margin: 10px auto 10px;
      width: 90%;
      max-width: 1000px;
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 16px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.06);
    }

    #gallery img {
      position: absolute;
      max-width: 92%;
      max-height: 92%;
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.25);
      opacity: 0;
      transition: opacity 0.8s ease-in-out;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      object-fit: contain;
    }

    #gallery img.active {
      opacity: 1;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #e2e8f0;
      border-top: 4px solid #007bff;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      from { transform: rotate(0); }
      to   { transform: rotate(360deg); }
    }

    .catalog-wrapper {
      max-width: 640px;
      margin: 10px auto 18px;
      padding: 6px 10px;
      border-radius: 999px;
      background: #e9edf7;
      box-shadow: 0 4px 12px rgba(15, 23, 42, 0.05);
      overflow-x: auto;
    }

    .catalog {
      display: flex;
      gap: 6px;
      padding: 2px;
      min-width: max-content;
      justify-content: center;
    }

    .catalog-btn {
      min-width: 32px;
      height: 32px;
      padding: 0;
      border-radius: 999px;
      border: 1px solid #c3cce5;
      background: white;
      font-size: 13px;
      color: #475569;
    }

    .catalog-btn.active {
      background: #007bff;
      border-color: #007bff;
      color: white;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.3);
    }

    .ctrls {
      margin-top: 10px;
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .ctrl-btn {
      padding: 10px 20px;
      border-radius: 999px;
      border: none;
      font-size: 14px;
      color: white;
      background: #2563eb;
    }

    .ctrl-btn.secondary {
      background: #64748b;
    }

    .ctrl-btn.danger {
      background: #e11d48;
    }

    .settings {
      width: 90%;
      max-width: 1000px;
      margin: 10px auto 12px;
      padding: 12px 14px;
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 16px;
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.06);
      text-align: left;
      display: grid;
      gap: 10px;
    }

    .settings-title {
      font-size: 14px;
      font-weight: 700;
      color: #0f172a;
      text-transform: uppercase;
      letter-spacing: 0.6px;
    }

    .settings-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    .settings-row label {
      font-size: 13px;
      color: #475569;
      margin-right: 6px;
    }

    .settings-row select,
    .settings-row input[type="checkbox"] {
      margin-right: 12px;
    }

    .agent-fab {
      position: fixed;
      right: 24px;
      bottom: 24px;
      z-index: 10;
      display: grid;
      gap: 10px;
      transform: translate3d(0, 0, 0);
      transition: transform 0.2s ease;
    }

    .agent-bubble {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.85);
      color: #f8fafc;
      font-weight: 700;
      letter-spacing: 0.6px;
      cursor: pointer;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.35);
      backdrop-filter: blur(8px);
      animation: bubbleFloat 6s ease-in-out infinite;
    }

    .agent-bubble {
      cursor: grab;
    }

    .agent-bubble:active {
      cursor: grabbing;
    }

    .agent-fab.dragging .agent-bubble {
      animation: none;
    }

    @keyframes bubbleFloat {
      0% { transform: translate3d(0, 0, 0); }
      50% { transform: translate3d(-6px, -8px, 0); }
      100% { transform: translate3d(0, 0, 0); }
    }

    .agent-panel {
      width: min(360px, calc(100vw - 32px));
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #e2e8f0;
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.2);
      padding: 14px 16px;
      display: none;
      grid-template-rows: auto 1fr auto;
      gap: 10px;
      overflow: hidden;
    }

    .agent-fab.open .agent-panel {
      display: grid;
    }


    .agent-log {
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      background: #f8fafc;
      padding: 10px;
      min-height: 120px;
      max-height: 260px;
      overflow-y: auto;
      overflow-x: hidden;
      display: grid;
      gap: 8px;
    }

    .agent-msg {
      display: grid;
      gap: 2px;
      font-size: 13px;
      color: #1f2937;
      word-break: break-word;
      overflow-wrap: anywhere;
      white-space: pre-wrap;
    }

    .agent-msg strong {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.6px;
      color: #64748b;
    }

    .agent-input {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .agent-input input {
      flex: 1;
      min-width: 180px;
    }

    .agent-status {
      font-size: 12px;
      color: #64748b;
      text-align: right;
    }

    .agent-fab.right .agent-panel {
      align-self: end;
    }

    .agent-fab.left .agent-panel {
      align-self: start;
    }

    .refine {
      width: 90%;
      max-width: 1000px;
      margin: 10px auto 12px;
      padding: 14px 16px;
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 16px;
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.06);
      text-align: left;
      display: grid;
      gap: 12px;
    }

    .refine-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .refine-actions input {
      flex: 1;
      min-width: 220px;
    }

    @media (max-width: 720px) {
      .refine-actions input {
        min-width: 100%;
      }
    }

    .history {
      width: 90%;
      max-width: 1000px;
      margin: 14px auto 16px;
      padding: 14px 16px;
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 16px;
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.06);
      text-align: left;
    }

    .history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 10px;
    }

    .history-title {
      font-size: 16px;
      font-weight: 700;
      color: #0f172a;
    }

    .history-clear {
      border-radius: 999px;
      border: 1px solid #cbd5e1;
      background: #f8fafc;
      color: #334155;
      padding: 6px 12px;
      cursor: pointer;
    }

    .history-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
    }

    .history-card {
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 10px;
      background: #f8fafc;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .history-card-head {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .history-keyword {
      font-weight: 600;
      color: #0f172a;
    }

    .history-meta {
      font-size: 12px;
      color: #64748b;
    }

    .history-thumbs {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    .history-thumbs img {
      width: 100%;
      height: 70px;
      border-radius: 8px;
      object-fit: cover;
    }

    .history-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .history-count {
      font-size: 12px;
      color: #475569;
    }

    .history-restore {
      border-radius: 999px;
      border: none;
      background: #2563eb;
      color: white;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 12px;
    }

    .history-empty {
      color: #94a3b8;
      font-size: 13px;
      padding: 8px 2px;
    }

    .session {
      width: 90%;
      max-width: 1000px;
      margin: 10px auto 24px;
      padding: 14px 16px;
      border-radius: 16px;
      border: 1px dashed #cbd5e1;
      background: #f8fafc;
      text-align: left;
      display: grid;
      gap: 12px;
    }

    .session-title {
      font-weight: 700;
      color: #0f172a;
    }

    .session-grid {
      display: grid;
      grid-template-columns: 140px 1fr;
      gap: 14px;
      align-items: center;
    }

    .session-qr {
      width: 140px;
      height: 140px;
      border-radius: 10px;
      border: 1px solid #e2e8f0;
      background: white;
      object-fit: cover;
    }

    .session-meta {
      display: grid;
      gap: 6px;
      font-size: 14px;
      color: #475569;
    }

    .session-code {
      font-weight: 700;
      color: #2563eb;
    }

    .session-link a {
      color: #1d4ed8;
      word-break: break-all;
    }

    @media (max-width: 640px) {
      .session-grid {
        grid-template-columns: 1fr;
      }
      .session-qr {
        width: 120px;
        height: 120px;
      }
    }
    /* Diffusion-style reveal animation */
@keyframes diffusionReveal {
  0% {
    filter: blur(30px) brightness(0.6) contrast(0.8);
    opacity: 0.2;
  }
  40% {
    filter: blur(18px) brightness(0.8) contrast(0.9);
    opacity: 0.6;
  }
  80% {
    filter: blur(8px) brightness(1) contrast(1);
    opacity: 0.95;
  }
  100% {
    filter: blur(0px) brightness(1) contrast(1);
    opacity: 1;
  }
}

#unsplash-preview.animate {
  animation: diffusionReveal 1.6s ease-out forwards;
}

    /* =============================
         AI Loading Overlay
    ============================== */
    #ai-loading {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.92);
      color: #fff;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 30px;
      z-index: 99999;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.35s ease;
    }

    #ai-loading.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .sketch {
      width: 150px;
      height: 150px;
      background: url('sketch.svg') no-repeat center;
      background-size: contain;
      opacity: 0.8;
      animation: sketchPulse 1.8s ease-in-out infinite;
      filter: invert(1);
    }

    @keyframes sketchPulse {
      0% { opacity: 0.2; transform: scale(0.9); }
      50% { opacity: 1; transform: scale(1.05); }
      100% { opacity: 0.2; transform: scale(0.9); }
    }

    #unsplash-preview {
      width: 360px;
      height: 280px;
      object-fit: cover;
      opacity: 0;
      filter: blur(14px);
      border-radius: 14px;
      transition: opacity 1s, filter 1.6s;
    }

  </style>
</head>

<body>

  <div class="view-toggle">
    <button id="view-weather" class="active">Weather</button>
    <button id="view-app">Gallery</button>
  </div>

  <section class="weather" id="weather-view">
    <div class="weather-bg">
      <div class="weather-bg-layer is-active" id="weather-bg-a"></div>
      <div class="weather-bg-layer" id="weather-bg-b"></div>
    </div>
    <div class="weather-content">
      <div class="weather-title">Local weather wallpaper</div>
      <div class="weather-main">
        <div class="weather-temp" id="weather-temp">--°</div>
        <div class="weather-meta">
          <div id="weather-city">Locating...</div>
          <div id="weather-desc">—</div>
        </div>
      </div>
      <div class="weather-extra">
        <span id="weather-humidity">Humidity —</span>
        <span id="weather-wind">Wind —</span>
        <span id="weather-time">Updated —</span>
      </div>
    </div>
  </section>

  <div id="app-view" class="app-view view-hidden">
  <h1>VISTA — Image Library + AI</h1>

  <div class="control-panels">
    <div class="panel">
      <div class="panel-title">Search library</div>
      <div class="panel-row">
        <input id="search-keyword" type="text" placeholder="Search keyword (e.g. dog, future city)" />
        <select id="mode" onchange="onModeChange()">
          <option value="unsplash" selected>Unsplash</option>
          <option value="pexels">Pexels</option>
        </select>
        <select id="library-ratio">
          <option value="1:1" selected>1:1</option>
          <option value="4:3">4:3</option>
          <option value="16:9">16:9</option>
          <option value="3:4">3:4</option>
          <option value="9:16">9:16</option>
        </select>
        <button class="primary" onclick="searchLibrary()">Search</button>
      </div>
    </div>

    <div class="panel">
      <div class="panel-title">AI generate (Flux)</div>
      <div class="panel-row">
        <input id="ai-prompt" type="text" placeholder="Describe what to generate..." />
        <select id="ai-count">
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3" selected>3</option>
          <option value="4">4</option>
          <option value="5">5</option>
        </select>
        <select id="ai-size">
          <option value="1:1" selected>1:1</option>
          <option value="4:3">4:3</option>
          <option value="16:9">16:9</option>
          <option value="3:4">3:4</option>
          <option value="9:16">9:16</option>
        </select>
        <button class="primary" onclick="generateAi()">Generate</button>
      </div>
    </div>
  </div>

  <div id="status"></div>

  <div id="gallery"><p>Try searching or generating!</p></div>

  <div class="catalog-wrapper" id="catalog-wrapper" style="display:none;">
    <div class="catalog" id="catalog"></div>
  </div>

  <div class="ctrls">
    <button class="ctrl-btn" onclick="startSlideshow()">▶ Play</button>
    <button class="ctrl-btn secondary" onclick="stopSlideshow()">⏹ Stop</button>
    <button class="ctrl-btn secondary" onclick="toggleFullscreen()">⛶ Fullscreen</button>
    <button class="ctrl-btn secondary" onclick="downloadCurrent()">⬇ Download</button>
    <button class="ctrl-btn danger" onclick="clearGallery()">Clear</button>
  </div>

  <div class="settings" id="settings">
    <div class="settings-title">Playback settings</div>
    <div class="settings-row">
      <label for="speed-select">Speed</label>
      <select id="speed-select">
        <option value="2000">Fast (2s)</option>
        <option value="3000" selected>Normal (3s)</option>
        <option value="5000">Slow (5s)</option>
      </select>

      <label for="autoplay-toggle">Autoplay</label>
      <input id="autoplay-toggle" type="checkbox" />
    </div>
  </div>

  <div class="refine" id="refine">
    <div class="settings-title">Refine image (Flux Kontext)</div>
    <div class="refine-actions">
      <input id="refine-prompt" type="text" placeholder="Describe how to edit the current image..." />
      <button class="primary" onclick="refineCurrent()">Refine</button>
      <button class="secondary" onclick="downloadRefined()">Download refined</button>
    </div>
    <div id="refine-status" style="font-size:13px;color:#64748b;"></div>
  </div>

  <div class="agent-fab right" id="agent-fab">
    <button class="agent-bubble" id="agent-bubble">AI</button>
    <div class="agent-panel" id="agent-panel">
      <div class="agent-input">
        <input id="agent-input" type="text" placeholder="Ask the agent to search, generate, or refine..." />
        <button class="primary" id="agent-send">Send</button>
      </div>
      <div class="agent-log" id="agent-log"></div>
      <div class="agent-status" id="agent-status">Ready.</div>
    </div>
  </div>

  <div class="history" id="history">
    <div class="history-header">
      <div class="history-title">Result history</div>
      <button class="history-clear" onclick="clearHistory()">Clear history</button>
    </div>
    <div class="history-grid" id="history-grid"></div>
  </div>

  <div class="session" id="sessionBox">
    <div class="session-title">Remote control</div>
    <div class="session-grid">
      <img class="session-qr" id="session-qr" alt="QR code" />
      <div class="session-meta">
        <div>Scan the QR code to open the phone remote.</div>
        <div>Short code: <span class="session-code" id="session-code">—</span></div>
        <div class="session-link"><a id="session-link" href="#" target="_blank">—</a></div>
      </div>
    </div>
  </div>

  <!-- AI Loading Overlay -->
  <div id="ai-loading">
    <div class="sketch"></div>
    <p id="loading-text">Creating your image...</p>
    <img id="unsplash-preview" />
  </div>

  </div>
  

<script>
  /* =====================================================
             FORCE DOWNLOAD (UNSPLASH/PEXELS/LEXICA)
===================================================== */
async function forceDownload(url, filename) {
  try {
    const res = await fetch(url);
    const blob = await res.blob();

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(a.href);
  } catch (err) {
    console.error("Download failed:", err);
    alert("Failed to download image.");
  }
}
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    hideAILoading();
  }
});


/* =====================================================
             AI LOADING + UNSPLASH PREVIEW
===================================================== */
let previewTimer = null;

function showAILoading(keyword) {
  document.getElementById("ai-loading").classList.add("visible");
  startUnsplashPreview(keyword);
}

function hideAILoading() {
  document.getElementById("ai-loading").classList.remove("visible");
  clearInterval(previewTimer);
}

async function startUnsplashPreview(keyword) {
  const imgBox = document.getElementById("unsplash-preview");

  try {
    const r = await fetch(
      `${API_BASE}/api/unsplash?q=${encodeURIComponent(keyword)}&page=1`
    );
    const data = await r.json();
    const images = data.images || [];
    if (!images.length) return;

    let index = 0;

    // 显示第一张
    imgBox.classList.remove("animate");
    void imgBox.offsetWidth;
    imgBox.src = images[0];
    imgBox.classList.add("animate");

    // 每 1.5 秒切一张并执行 diffusion reveal
    previewTimer = setInterval(() => {
      index = (index + 1) % images.length;

      imgBox.classList.remove("animate");
      void imgBox.offsetWidth;

      imgBox.src = images[index];
      imgBox.classList.add("animate");
    }, 4000);

  } catch (e) {
    console.log(e);
  }
}

/* =====================================================
             YOUR ORIGINAL LOGIC BELOW
===================================================== */
const API_BASE = "https://vista-backend-1-6r3t.onrender.com";
const FRONTEND_BASE = "https://1195898560zyy-del.github.io/vistapj";
const WEATHER_CACHE_KEY = "vista_weather_cache_v1";
const WEATHER_TTL = 10 * 60 * 1000;
const WEATHER_ROTATE_MS = 12000;

let slideIndex = 0;
let slideTimer = null;
let slideInterval = 3000;
let isPlaying = false;

let currentKeyword = "";
let currentPage = 1;
let totalPages = 1;

let sessionID = null;
let sessionCode = null;
let sessionPoll = null;
let agentLog = [];

const HISTORY_KEY = "vista_result_history_v1";
const HISTORY_LIMIT = 5;
const HISTORY_MAX_IMAGES = 9;
const HISTORY_MAX_BYTES = 4000000;
let lastRefinedUrl = "";
let currentCycleId = null;
let currentCycleRefines = 0;

function setStatus(msg) {
  document.getElementById("status").textContent = msg || "";
}

function getAgentLog() {
  return agentLog;
}

function saveAgentLog(items) {
  agentLog = items.slice(-20);
}

function appendAgentMessage(role, content) {
  const log = getAgentLog();
  log.push({ role, content, ts: Date.now() });
  saveAgentLog(log);
  renderAgentLog();
}

function renderAgentLog() {
  const logEl = document.getElementById("agent-log");
  if (!logEl) return;
  logEl.innerHTML = "";
  const items = getAgentLog();
  if (!items.length) {
    const empty = document.createElement("div");
    empty.className = "agent-msg";
    empty.textContent = "No messages yet.";
    logEl.appendChild(empty);
    return;
  }
  items.forEach((item) => {
    const cleaned = sanitizeAgentReply(item.content || "");
    if (!cleaned) return;
    const row = document.createElement("div");
    row.className = "agent-msg";
    const label = document.createElement("strong");
    label.textContent = item.role === "assistant" ? "Agent" : "You";
    const text = document.createElement("div");
    text.textContent = cleaned;
    row.appendChild(label);
    row.appendChild(text);
    logEl.appendChild(row);
  });
  logEl.scrollTop = logEl.scrollHeight;
}

function setAgentStatus(text) {
  const el = document.getElementById("agent-status");
  if (el) el.textContent = text;
}

function clearAgentLog() {
  agentLog = [];
  const logEl = document.getElementById("agent-log");
  if (logEl) logEl.innerHTML = "";
}

function resetAgentLog() {
  clearAgentLog();
  renderAgentLog();
}

function buildAgentSummary() {
  const items = getAgentLog().slice(-6);
  return items.map((item) => `${item.role}: ${item.content}`).join(" | ");
}

function buildAgentState() {
  const mode = document.getElementById("mode");
  const ratio = document.getElementById("library-ratio");
  const aiCount = document.getElementById("ai-count");
  const aiSize = document.getElementById("ai-size");
  return {
    mode: mode ? mode.value : null,
    ratio: ratio ? ratio.value : null,
    ai_count: aiCount ? aiCount.value : null,
    ai_ratio: aiSize ? aiSize.value : null
  };
}

function readWeatherCache() {
  try {
    const raw = localStorage.getItem(WEATHER_CACHE_KEY);
    return raw ? JSON.parse(raw) : null;
  } catch (err) {
    return null;
  }
}

function writeWeatherCache(data) {
  try {
    localStorage.setItem(WEATHER_CACHE_KEY, JSON.stringify(data));
  } catch (err) {
    // ignore cache errors
  }
}

function formatWeatherTime(dt, tz) {
  if (!dt || tz === undefined || tz === null) return "Updated —";
  const localMs = (dt + tz) * 1000;
  const local = new Date(localMs);
  const hh = String(local.getUTCHours()).padStart(2, "0");
  const mm = String(local.getUTCMinutes()).padStart(2, "0");
  return `Updated ${hh}:${mm}`;
}

function weatherToQuery(main = "", description = "", isNight = false) {
  const base = main.toLowerCase();
  const desc = description.toLowerCase();
  if (base.includes("thunder")) return "thunderstorm skyline, dramatic clouds, cinematic";
  if (base.includes("snow")) return "snowy landscape, soft light, serene, cinematic";
  if (base.includes("rain") || desc.includes("drizzle")) return "rainy city street, reflections, moody, cinematic";
  if (base.includes("fog") || base.includes("mist") || desc.includes("haze")) {
    return "foggy forest, atmospheric, muted tones, cinematic";
  }
  if (base.includes("cloud")) return "overcast mountains, soft light, minimal, cinematic";
  if (base.includes("clear") && isNight) return "clear night sky, stars, calm city, cinematic";
  if (base.includes("clear")) return "sunny horizon, warm light, crisp air, cinematic";
  return "cinematic landscape, soft light, atmospheric";
}

function applyWeatherUI(data) {
  const tempEl = document.getElementById("weather-temp");
  const cityEl = document.getElementById("weather-city");
  const descEl = document.getElementById("weather-desc");
  const humEl = document.getElementById("weather-humidity");
  const windEl = document.getElementById("weather-wind");
  const timeEl = document.getElementById("weather-time");

  if (tempEl && data.temp !== null && data.temp !== undefined) {
    tempEl.textContent = `${Math.round(data.temp)}°`;
  }
  if (cityEl) cityEl.textContent = data.city || "Unknown location";
  if (descEl) descEl.textContent = data.description || data.main || "—";
  if (humEl) humEl.textContent = data.humidity !== null && data.humidity !== undefined
    ? `Humidity ${data.humidity}%`
    : "Humidity —";
  if (windEl) windEl.textContent = data.wind !== null && data.wind !== undefined
    ? `Wind ${Math.round(data.wind)} m/s`
    : "Wind —";
  if (timeEl) timeEl.textContent = formatWeatherTime(data.dt, data.timezone);
}

let weatherSlideTimer = null;
let weatherImages = [];
let weatherImageIndex = 0;
let weatherLayerIndex = 0;

function setWeatherBackground(url) {
  const layerA = document.getElementById("weather-bg-a");
  const layerB = document.getElementById("weather-bg-b");
  if (!layerA || !layerB || !url) return;

  const nextLayer = weatherLayerIndex === 0 ? layerB : layerA;
  const currentLayer = weatherLayerIndex === 0 ? layerA : layerB;

  nextLayer.style.backgroundImage = `url(${url})`;
  nextLayer.classList.add("is-active");
  currentLayer.classList.remove("is-active");
  weatherLayerIndex = weatherLayerIndex === 0 ? 1 : 0;
}

function startWeatherSlideshow(images) {
  if (!images || !images.length) return;
  clearInterval(weatherSlideTimer);
  weatherImages = images;
  weatherImageIndex = 0;
  setWeatherBackground(weatherImages[0]);
  weatherSlideTimer = setInterval(() => {
    weatherImageIndex = (weatherImageIndex + 1) % weatherImages.length;
    setWeatherBackground(weatherImages[weatherImageIndex]);
  }, WEATHER_ROTATE_MS);
}

async function applyWeatherBackdrop(data, cachedImages) {
  if (cachedImages && cachedImages.length) {
    startWeatherSlideshow(cachedImages);
    return;
  }

  const isNight = (data.icon || "").includes("n");
  const query = weatherToQuery(data.main || "", data.description || "", isNight);
  try {
    const pixelRatio = Math.min(window.devicePixelRatio || 1, 2);
    const targetW = Math.round(window.innerWidth * pixelRatio);
    const targetH = Math.round(window.innerHeight * pixelRatio);
    const r = await fetch(
      `${API_BASE}/api/unsplash?q=${encodeURIComponent(query)}&random=1&ratio=16:9&w=${targetW}&h=${targetH}`
    );
    const res = await r.json();
    const images = res.images || [];
    if (images.length) {
      startWeatherSlideshow(images);
      const cached = readWeatherCache() || {};
      cached.images = images;
      writeWeatherCache(cached);
    }
  } catch (err) {
    // ignore backdrop failures
  }
}

async function fetchWeather(lat, lon) {
  const r = await fetch(`${API_BASE}/api/weather?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}`);
  const data = await r.json();
  if (!r.ok) {
    throw new Error(data.error || "Weather failed");
  }
  return data;
}

function initWeather() {
  const cached = readWeatherCache();
  if (cached && cached.ts && Date.now() - cached.ts < WEATHER_TTL) {
    applyWeatherUI(cached.data || {});
    applyWeatherBackdrop(cached.data || {}, cached.images || []);
    return;
  }

  if (!navigator.geolocation) {
    applyWeatherUI({ city: "Location disabled", description: "Geolocation not supported" });
    return;
  }

  navigator.geolocation.getCurrentPosition(
    async (pos) => {
      try {
        const data = await fetchWeather(pos.coords.latitude, pos.coords.longitude);
        applyWeatherUI(data);
        applyWeatherBackdrop(data);
        writeWeatherCache({ ts: Date.now(), data, images: [] });
      } catch (err) {
        applyWeatherUI({ city: "Weather unavailable", description: err.message });
      }
    },
    () => {
      applyWeatherUI({ city: "Location blocked", description: "Enable location to show weather" });
    },
    { enableHighAccuracy: false, timeout: 8000, maximumAge: 600000 }
  );
}

function loadHistory() {
  try {
    const raw = localStorage.getItem(HISTORY_KEY);
    const parsed = raw ? JSON.parse(raw) : [];
    return Array.isArray(parsed) ? parsed : [];
  } catch (err) {
    return [];
  }
}

function saveHistory(history) {
  let trimmed = history.slice(0, HISTORY_LIMIT);
  let json = JSON.stringify(trimmed);
  while (json.length > HISTORY_MAX_BYTES && trimmed.length > 1) {
    trimmed.pop();
    json = JSON.stringify(trimmed);
  }
  localStorage.setItem(HISTORY_KEY, json);
  return trimmed;
}

function buildHistoryEntry(mode, keyword, urls) {
  const kept = [];
  let usedDataUrl = false;
  urls.forEach((url) => {
    if (kept.length >= HISTORY_MAX_IMAGES) return;
    if (url.startsWith("data:image")) {
      if (usedDataUrl) return;
      usedDataUrl = true;
    }
    kept.push(url);
  });
  return {
    id: `${Date.now()}_${Math.random().toString(16).slice(2)}`,
    mode,
    keyword,
    urls: kept,
    total: urls.length,
    ts: Date.now(),
    refines: 0
  };
}

function addHistory(mode, keyword, urls) {
  const history = loadHistory();
  const entry = buildHistoryEntry(mode, keyword, urls);
  history.unshift(entry);
  const saved = saveHistory(history);
  currentCycleId = entry.id;
  currentCycleRefines = 0;
  renderHistory(saved);
}

function updateHistoryForRefine(refinedUrl) {
  if (!currentCycleId || !refinedUrl) return;
  const history = loadHistory();
  const entry = history.find((item) => item.id === currentCycleId);
  if (!entry) return;
  entry.refines = (entry.refines || 0) + 1;
  entry.total = entry.total || (entry.urls ? entry.urls.length : 0);
  const nextUrls = [refinedUrl].concat(entry.urls || []);
  entry.urls = nextUrls.slice(0, HISTORY_MAX_IMAGES);
  const saved = saveHistory(history);
  currentCycleRefines = entry.refines;
  renderHistory(saved);
}

function clearHistory() {
  localStorage.removeItem(HISTORY_KEY);
  renderHistory([]);
}

function formatHistoryTime(ts) {
  try {
    return new Date(ts).toLocaleString();
  } catch (err) {
    return "";
  }
}

function renderHistory(history = loadHistory()) {
  const grid = document.getElementById("history-grid");
  if (!grid) return;
  grid.innerHTML = "";

  if (!history.length) {
    const empty = document.createElement("div");
    empty.className = "history-empty";
    empty.textContent = "No history yet. Run a search or generate images.";
    grid.appendChild(empty);
    return;
  }

  history.forEach((entry) => {
    const card = document.createElement("div");
    card.className = "history-card";

    const head = document.createElement("div");
    head.className = "history-card-head";

    const keyword = document.createElement("div");
    keyword.className = "history-keyword";
    keyword.textContent = entry.keyword || "(no keyword)";

    const meta = document.createElement("div");
    meta.className = "history-meta";
    const modeLabel = entry.mode || "unknown";
    const refineCount = entry.refines ? ` · ${entry.refines} refine${entry.refines > 1 ? "s" : ""}` : "";
    meta.textContent = `${modeLabel} · ${formatHistoryTime(entry.ts)}${refineCount}`;

    head.appendChild(keyword);
    head.appendChild(meta);

    const thumbs = document.createElement("div");
    thumbs.className = "history-thumbs";
    (entry.urls || []).forEach((url) => {
      const img = document.createElement("img");
      img.src = url;
      img.alt = entry.keyword || "history";
      img.loading = "lazy";
      thumbs.appendChild(img);
    });

    const footer = document.createElement("div");
    footer.className = "history-footer";

    const count = document.createElement("span");
    count.className = "history-count";
    const totalText = entry.total && entry.total !== (entry.urls || []).length
      ? `${(entry.urls || []).length}/${entry.total}`
      : `${(entry.urls || []).length}`;
    count.textContent = `${totalText} images`;

    const restore = document.createElement("button");
    restore.className = "history-restore";
    restore.textContent = "Restore";
    restore.addEventListener("click", () => restoreHistory(entry.id));

    footer.appendChild(count);
    footer.appendChild(restore);

    card.appendChild(head);
    card.appendChild(thumbs);
    card.appendChild(footer);
    grid.appendChild(card);
  });
}

function restoreHistory(id) {
  const history = loadHistory();
  const entry = history.find((item) => item.id === id);
  if (!entry || !entry.urls || !entry.urls.length) {
    setStatus("No images found in history.");
    return;
  }

  stopSlideshow();
  const searchInput = document.getElementById("search-keyword");
  const aiPromptInput = document.getElementById("ai-prompt");
  const nextKeyword = entry.keyword || "";
  if (searchInput) searchInput.value = nextKeyword;
  if (aiPromptInput) aiPromptInput.value = nextKeyword;
  const modeSelect = document.getElementById("mode");
  if (entry.mode && entry.mode !== "flux") {
    modeSelect.value = entry.mode;
    onModeChange();
  }

  const g = document.getElementById("gallery");
  g.innerHTML = "";
  entry.urls.forEach((url, i) => createImg(url, entry.keyword, i === 0));
  buildCatalog(entry.urls.length);
  setActive(0);
  currentCycleId = entry.id || null;
  currentCycleRefines = entry.refines || 0;
  setStatus("Restored from history.");
}

function buildRemoteUrl(id) {
  return `${FRONTEND_BASE}/remote.html?session=${encodeURIComponent(id)}`;
}

function updateSessionUI(url, code) {
  const link = document.getElementById("session-link");
  const codeEl = document.getElementById("session-code");
  const qr = document.getElementById("session-qr");
  if (link) {
    link.href = url;
    link.textContent = url;
  }
  if (codeEl) {
    codeEl.textContent = code || "—";
  }
  if (qr) {
    qr.src = `https://api.qrserver.com/v1/create-qr-code/?size=180x180&data=${encodeURIComponent(url)}`;
  }
}

async function initSession() {
  try {
    const stored = localStorage.getItem("vista_presenter_session");
    if (stored) {
      const ping = await fetch(`${API_BASE}/api/session/${encodeURIComponent(stored)}`);
      if (ping.ok) {
        sessionID = stored;
        sessionCode = "—";
        const remoteUrl = buildRemoteUrl(sessionID);
        updateSessionUI(remoteUrl, sessionCode);
        startCommandPolling();
        return;
      }
    }

    const res = await fetch(`${API_BASE}/api/session`, { method: "POST" });
    const data = await res.json();
    sessionID = data.session;
    sessionCode = data.code;
    localStorage.setItem("vista_presenter_session", sessionID);
    const remoteUrl = buildRemoteUrl(sessionID);
    updateSessionUI(remoteUrl, sessionCode);
    startCommandPolling();
  } catch (err) {
    console.error("Session init failed:", err);
  }
}

function startCommandPolling() {
  if (sessionPoll) clearInterval(sessionPoll);
  sessionPoll = setInterval(async () => {
    if (!sessionID) return;
    try {
      const res = await fetch(`${API_BASE}/api/check?session=${sessionID}`);
      const data = await res.json();
      if (data.command) {
        applyRemoteCommand(data.command);
      }
    } catch (err) {
      console.error("Polling error:", err);
    }
  }, 800);
}

function applyRemoteCommand(command) {
  if (!command || !command.type) return;

  if (command.type === "theme") {
    const searchInput = document.getElementById("search-keyword");
    const aiPromptInput = document.getElementById("ai-prompt");
    const ratioSelect = document.getElementById("library-ratio");
    const nextValue = command.keyword || "";
    if (searchInput) searchInput.value = nextValue;
    if (aiPromptInput) aiPromptInput.value = nextValue;
    if (command.mode) {
      const modeSelect = document.getElementById("mode");
      if (modeSelect) modeSelect.value = command.mode;
    }
    if (command.ratio && ratioSelect) {
      ratioSelect.value = command.ratio;
    }
    searchLibrary();
    return;
  }

  if (command.type === "mode") {
    const modeSelect = document.getElementById("mode");
    modeSelect.value = command.mode || "unsplash";
    onModeChange();
    return;
  }

  if (command.type === "play") {
    startSlideshow();
    return;
  }

  if (command.type === "pause") {
    stopSlideshow();
    return;
  }

  if (command.type === "next") {
    setActive(slideIndex + 1);
    return;
  }

  if (command.type === "prev") {
    setActive(slideIndex - 1);
    return;
  }

  if (command.type === "refresh") {
    searchLibrary();
    return;
  }

  if (command.type === "clear") {
    clearGallery();
    return;
  }

  if (command.type === "refine") {
    const refineInput = document.getElementById("refine-prompt");
    if (refineInput) {
      refineInput.value = command.prompt || "";
    }
    refineCurrent(true);
    return;
  }

  if (command.type === "ai_generate") {
    const aiPromptInput = document.getElementById("ai-prompt");
    const aiCountInput = document.getElementById("ai-count");
    const aiSizeInput = document.getElementById("ai-size");

    if (aiPromptInput) {
      aiPromptInput.value = command.keyword || aiPromptInput.value;
    }
    if (command.count) {
      aiCountInput.value = command.count;
    }
    if (command.size && aiSizeInput) {
      aiSizeInput.value = command.size;
    }
    generateAi();
    return;
  }
}

function clearGallery() {
  stopSlideshow();
  document.getElementById("gallery").innerHTML = "<p>Try searching or generating!</p>";
  document.getElementById("catalog").innerHTML = "";
  document.getElementById("catalog-wrapper").style.display = "none";
  setStatus("");
}

function addSpinner() {
  const g = document.getElementById("gallery");
  g.innerHTML = "";
  const s = document.createElement("div");
  s.className = "spinner";
  g.appendChild(s);
}

function removeSpinner() {
  const s = document.querySelector("#gallery .spinner");
  if (s) s.remove();
}

function createImg(src, alt, active = false) {
  const img = document.createElement("img");
  img.src = src;
  img.alt = alt;
  if (active) img.classList.add("active");
  document.getElementById("gallery").appendChild(img);
}

function getImages() {
  return document.querySelectorAll("#gallery img");
}

function updateCatalogActive(i) {
  const btns = document.querySelectorAll(".catalog-btn");
  btns.forEach((b, idx) => {
    b.classList.toggle("active", idx === i);
  });
}

function setActive(i) {
  const imgs = getImages();
  if (!imgs.length) return;
  imgs.forEach(im => im.classList.remove("active"));
  const target = imgs[i % imgs.length];
  target.classList.add("active");
  slideIndex = i % imgs.length;
  updateCatalogActive(slideIndex);
}

function buildCatalog(count) {
  const wrap = document.getElementById("catalog-wrapper");
  const catalog = document.getElementById("catalog");
  catalog.innerHTML = "";

  if (!count || count <= 1) {
    wrap.style.display = "none";
    return;
  }

  wrap.style.display = "block";

  for (let i = 0; i < count; i++) {
    const btn = document.createElement("button");
    btn.className = "catalog-btn";
    btn.textContent = i + 1;
    if (i === 0) btn.classList.add("active");
    btn.addEventListener("click", () => {
      stopSlideshow();
      setActive(i);
    });
    catalog.appendChild(btn);
  }
}

function startSlideshow() {
  const imgs = getImages();
  if (!imgs.length) return;
  stopSlideshow();
  slideIndex = 0;
  setActive(0);
  slideTimer = setInterval(() => {
    setActive(slideIndex + 1);
  }, slideInterval);
  isPlaying = true;
}

function stopSlideshow() {
  if (slideTimer) {
    clearInterval(slideTimer);
    slideTimer = null;
  }
  isPlaying = false;
}

function downloadCurrent() {
  const imgs = getImages();
  if (!imgs.length) return;

  const active = [...imgs].find(i => i.classList.contains("active")) || imgs[0];
  const url = active.src;

  const isUnsplash = url.includes("images.unsplash.com");
  const isPexels = url.includes("pexels.com") || url.includes("images.pexels.com");
  const isLexica = false;

  const filename =
    (isUnsplash ? "unsplash_" :
     isPexels   ? "pexels_"   :
                  "ai_") + Date.now() + ".jpg";

  // 强制下载第三方图库，AI 图走原生下载
  if (isUnsplash || isPexels || isLexica) {
    forceDownload(url, filename);
  } else {
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }
}


function toggleFullscreen() {
  const gallery = document.getElementById("gallery");
  if (!document.fullscreenElement &&
      !document.webkitFullscreenElement &&
      !document.msFullscreenElement) {

    if (gallery.requestFullscreen) gallery.requestFullscreen();
    else if (gallery.webkitRequestFullscreen) gallery.webkitRequestFullscreen();
    else if (gallery.msRequestFullscreen) gallery.msRequestFullscreen();
  } else {
    if (document.exitFullscreen) document.exitFullscreen();
    else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
    else if (document.msExitFullscreen) document.msExitFullscreen();
  }
}

function onModeChange() {
  // Placeholder for history restore/remote sync.
}

async function searchLibrary() {
  stopSlideshow();

  const keywordInput = document.getElementById("search-keyword");
  const ratioSelect = document.getElementById("library-ratio");
  const mode = document.getElementById("mode").value;
  const keyword = keywordInput.value.trim();
  const ratio = ratioSelect ? ratioSelect.value : "1:1";

  if (!keyword) {
    setStatus("Please enter a search keyword.");
    return;
  }

  addSpinner();

  try {
    if (mode === "unsplash") {

      if (keyword !== currentKeyword) {
        currentKeyword = keyword;
        currentPage = 1;
      }

      setStatus("Searching Unsplash... (random)");

      let r = await fetch(
        `${API_BASE}/api/unsplash?q=${encodeURIComponent(keyword)}&random=1&ratio=${encodeURIComponent(ratio)}`
      );

      let data = await r.json();
      totalPages = data.totalPages || 1;

      if (data.error || data.errors) {
        removeSpinner();
        const errMsg = (data.error && (data.error.message || data.error)) || data.errors;
        setStatus(`Unsplash failed: ${errMsg}`);
        return;
      }

      removeSpinner();

      const results = data.images || [];

      if (!results.length) {
        clearGallery();
        setStatus("No images found.");
        return;
      }

      const g = document.getElementById("gallery");
      g.innerHTML = "";
      results.forEach((url, i) => createImg(url, keyword, i === 0));

      buildCatalog(results.length);
      setStatus(`Unsplash loaded ${results.length} images.`);
      addHistory("unsplash", keyword, results);
      return;
    }
      // ===========================
// PEXELS
// ===========================
if (mode === "pexels") {
  setStatus("Searching Pexels...");

  const r = await fetch(`${API_BASE}/api/pexels?q=${encodeURIComponent(keyword)}&random=1&ratio=${encodeURIComponent(ratio)}`);
  const data = await r.json();

  removeSpinner();

  if (data.error) {
    clearGallery();
    setStatus(`Pexels failed: ${data.error}`);
    return;
  }

  if (!data.images || !data.images.length) {
    clearGallery();
    setStatus("No Pexels results found.");
    return;
  }

  const g = document.getElementById("gallery");
  g.innerHTML = "";
  data.images.forEach((url, i) => createImg(url, keyword, i === 0));

  buildCatalog(data.images.length);
  setStatus(`Pexels loaded ${data.images.length} images.`);
  addHistory("pexels", keyword, data.images);
  return;
}

  // ===========================
// LEXICA
// ===========================
// Lexica removed

  } catch (err) {
    console.error(err);
    removeSpinner();
    setStatus("Error: " + err.message);
  }
}

function searchOrGenerate() {
  return searchLibrary();
}

async function generateAi() {
  stopSlideshow();

  const promptInput = document.getElementById("ai-prompt");
  const prompt = promptInput.value.trim();

  if (!prompt) {
    setStatus("Please enter a generate prompt.");
    return;
  }

  addSpinner();
  setStatus("Generating Flux images...");
  showAILoading(prompt);

  let count = parseInt(document.getElementById("ai-count").value, 10);
  if (isNaN(count) || count < 1) count = 1;
  if (count > 5) count = 5;

  const aiSize = document.getElementById("ai-size");
  const aspectRatio = aiSize ? aiSize.value : "1:1";

  try {
    const r = await fetch(`${API_BASE}/api/replicate`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        prompt,
        count,
        aspect_ratio: aspectRatio
      })
    });

    const data = await r.json();
    removeSpinner();
    hideAILoading();

    const images = data.images || [];
    if (!images.length) {
      clearGallery();
      const errMsg = (data.error && (data.error.message || data.error)) || "No images returned.";
      setStatus(`Flux failed: ${errMsg}`);
      return;
    }

    const g = document.getElementById("gallery");
    g.innerHTML = "";
    images.forEach((url, i) => createImg(url, prompt, i === 0));

    buildCatalog(images.length);
    setStatus(`Flux loaded ${images.length} images.`);
    addHistory("flux", prompt, images);
  } catch (err) {
    console.error(err);
    removeSpinner();
    hideAILoading();
    setStatus("Error: " + err.message);
  }
}

renderHistory();
initSession();
initWeather();
initViewToggle();
initAgentBubble();
resetAgentLog();

window.addEventListener("load", resetAgentLog);
window.addEventListener("pageshow", (event) => {
  if (event.persisted) resetAgentLog();
});

const speedSelect = document.getElementById("speed-select");
const autoplayToggle = document.getElementById("autoplay-toggle");

if (speedSelect) {
  speedSelect.addEventListener("change", () => {
    const value = parseInt(speedSelect.value, 10);
    if (!Number.isNaN(value)) {
      slideInterval = value;
      if (isPlaying) {
        startSlideshow();
      }
    }
  });
}

if (autoplayToggle) {
  autoplayToggle.addEventListener("change", () => {
    if (autoplayToggle.checked) {
      startSlideshow();
    } else {
      stopSlideshow();
    }
  });
}

function updateRefineStatus(msg) {
  const el = document.getElementById("refine-status");
  if (el) el.textContent = msg || "";
}

async function refineCurrent(skipConfirm = false) {
  const promptInput = document.getElementById("refine-prompt");
  const prompt = promptInput.value.trim();
  if (!prompt) {
    updateRefineStatus("Please enter a refine prompt.");
    return;
  }

  const imgs = getImages();
  const active = [...imgs].find(i => i.classList.contains("active")) || imgs[0];
  const inputImage = active ? active.src : "";
  if (!inputImage) {
    updateRefineStatus("No image selected.");
    return;
  }
  if (inputImage.startsWith("data:")) {
    updateRefineStatus("Refine supports URL images only. Use Unsplash/Pexels/Lexica/Flux outputs.");
    return;
  }

  if (!skipConfirm) {
    const ok = confirm("Refine will use a paid API call. Continue?");
    if (!ok) {
      updateRefineStatus("Refine canceled.");
      return;
    }
  }

  updateRefineStatus("Refining...");
  try {
    const r = await fetch(`${API_BASE}/api/refine`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        prompt,
        input_image: inputImage
      })
    });
    const data = await r.json();
    if (!r.ok || !data.image) {
      updateRefineStatus(`Refine failed: ${data.error || "No image returned."}`);
      return;
    }
    lastRefinedUrl = data.image;
    updateHistoryForRefine(data.image);

    const g = document.getElementById("gallery");
    g.innerHTML = "";
    createImg(data.image, prompt, true);
    buildCatalog(1);
    setActive(0);
    updateRefineStatus("Refine complete.");
  } catch (err) {
    updateRefineStatus(`Refine error: ${err.message}`);
  }
}

function downloadRefined() {
  if (!lastRefinedUrl) {
    updateRefineStatus("No refined image yet.");
    return;
  }
  const a = document.createElement("a");
  a.href = lastRefinedUrl;
  a.download = `refined_${Date.now()}.jpg`;
  document.body.appendChild(a);
  a.click();
  a.remove();
}

async function sendAgentMessage() {
  const input = document.getElementById("agent-input");
  const button = document.getElementById("agent-send");
  if (!input) return;
  const rawText = input.value.trim();
  if (!rawText) return;
  const text = normalizeAgentMessage(rawText);

  appendAgentMessage("user", rawText);
  input.value = "";
  setAgentStatus("Thinking...");
  if (button) button.disabled = true;

  try {
    const r = await fetch(`${API_BASE}/api/agent`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        message: text,
        summary: buildAgentSummary(),
        state: buildAgentState()
      })
    });
    const data = await r.json();
    if (!r.ok) {
      throw new Error(data.error || "Agent failed");
    }
    if (data.tool && data.result) {
      applyAgentResult(data.tool, data.result, data.tool_args || {}, text);
    }
    if (data.tool) {
      appendAgentMessage("assistant", buildAgentAck(data.tool));
    } else if (data.reply) {
      appendAgentMessage("assistant", sanitizeAgentReply(data.reply));
    }
    setAgentStatus("Ready.");
  } catch (err) {
    appendAgentMessage("assistant", `Error: ${err.message}`);
    setAgentStatus("Error");
  } finally {
    if (button) button.disabled = false;
  }
}

function sanitizeAgentReply(text) {
  if (!text) return "";
  let cleaned = text.replace(/!\[[^\]]*?\]\([^)]+?\)/g, "");
  cleaned = cleaned.replace(/\[[^\]]*?\]\((https?:\/\/[^)]+?)\)/g, "");
  cleaned = cleaned.replace(/https?:\/\/\S+/g, "");
  cleaned = cleaned.replace(/\S+\/\S*(crop=|ixid=|ixlib=|fm=|fit=)\S*/gi, "");
  cleaned = cleaned
    .split("\n")
    .map((line) => line.trim())
    .filter((line) => line && !/^[\d\-•]+\.?$/.test(line));
  cleaned = cleaned.join("\n").replace(/\s{2,}/g, " ").trim();
  return cleaned || "Got it.";
}

function buildAgentAck(tool) {
  if (tool === "search_library") return "Search done. Gallery updated.";
  if (tool === "generate_ai") return "Generated. Gallery updated.";
  if (tool === "refine_image") return "Refine done. Gallery updated.";
  return "Done.";
}

function normalizeAgentMessage(text) {
  return text.replace(/\bpiexl\b/gi, "pexels").replace(/\bpexel\b/gi, "pexels");
}

function applyAgentResult(tool, result, args, fallbackText) {
  if (tool === "search_library") {
    const images = result.images || [];
    if (!images.length) {
      setStatus("No images found.");
      return;
    }
    const keyword = args.query || fallbackText || "";
    const g = document.getElementById("gallery");
    g.innerHTML = "";
    images.forEach((url, i) => createImg(url, keyword, i === 0));
    buildCatalog(images.length);
    setStatus(`Loaded ${images.length} images.`);
    addHistory(result.source || "unsplash", keyword, images);
  }

  if (tool === "generate_ai") {
    const images = result.images || [];
    if (!images.length) {
      setStatus("No images generated.");
      return;
    }
    const keyword = args.prompt || fallbackText || "";
    const g = document.getElementById("gallery");
    g.innerHTML = "";
    images.forEach((url, i) => createImg(url, keyword, i === 0));
    buildCatalog(images.length);
    setStatus(`Generated ${images.length} images.`);
    addHistory("flux", keyword, images);
  }

  if (tool === "refine_image") {
    const image = result.image || "";
    if (!image) {
      updateRefineStatus("No refined image.");
      return;
    }
    const g = document.getElementById("gallery");
    g.innerHTML = "";
    createImg(image, args.prompt || "refine", true);
    buildCatalog(1);
    setActive(0);
    lastRefinedUrl = image;
    updateHistoryForRefine(image);
    updateRefineStatus("Refine complete.");
  }
}

const agentSend = document.getElementById("agent-send");
const agentInput = document.getElementById("agent-input");
if (agentSend) agentSend.addEventListener("click", sendAgentMessage);
if (agentInput) {
  agentInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      sendAgentMessage();
    }
  });
}

function initViewToggle() {
  const weatherBtn = document.getElementById("view-weather");
  const appBtn = document.getElementById("view-app");
  const weatherView = document.getElementById("weather-view");
  const appView = document.getElementById("app-view");
  const VIEW_KEY = "vista_view_mode";

  function setView(mode) {
    const showWeather = mode === "weather";
    if (weatherView) weatherView.classList.toggle("view-hidden", !showWeather);
    if (appView) appView.classList.toggle("view-hidden", showWeather);
    if (weatherBtn) weatherBtn.classList.toggle("active", showWeather);
    if (appBtn) appBtn.classList.toggle("active", !showWeather);
    localStorage.setItem(VIEW_KEY, mode);
  }

  if (weatherBtn) weatherBtn.addEventListener("click", () => setView("weather"));
  if (appBtn) appBtn.addEventListener("click", () => setView("app"));

  const saved = localStorage.getItem(VIEW_KEY) || "weather";
  setView(saved);
}

function initAgentBubble() {
  const fab = document.getElementById("agent-fab");
  const bubble = document.getElementById("agent-bubble");
  if (!fab || !bubble) return;

  const POS_KEY = "vista_agent_pos_v1";
  const canHover = window.matchMedia && window.matchMedia("(hover: hover) and (pointer: fine)").matches;
  let drag = { active: false, moved: false, startX: 0, startY: 0, x: 0, y: 0 };

  function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }

  function applyPosition(x, y) {
    const maxX = window.innerWidth - bubble.offsetWidth - 16;
    const maxY = window.innerHeight - bubble.offsetHeight - 16;
    const nextX = clamp(x, 16, maxX);
    const nextY = clamp(y, 16, maxY);
    fab.style.transform = `translate3d(${nextX}px, ${nextY}px, 0)`;
    drag.x = nextX;
    drag.y = nextY;
  }

  function snap() {
    const maxX = window.innerWidth - bubble.offsetWidth - 16;
    const toLeft = drag.x < window.innerWidth / 2;
    const nextX = toLeft ? 16 : maxX;
    applyPosition(nextX, drag.y);
    fab.classList.toggle("left", toLeft);
    fab.classList.toggle("right", !toLeft);
    localStorage.setItem(POS_KEY, JSON.stringify({ x: nextX, y: drag.y }));
  }

  const stored = localStorage.getItem(POS_KEY);
  if (stored) {
    try {
      const pos = JSON.parse(stored);
      applyPosition(pos.x, pos.y);
      fab.classList.toggle("left", pos.x < window.innerWidth / 2);
      fab.classList.toggle("right", pos.x >= window.innerWidth / 2);
    } catch (err) {
      applyPosition(0, 0);
      snap();
    }
  } else {
    applyPosition(0, 0);
    snap();
  }

  bubble.addEventListener("pointerdown", (e) => {
    drag.active = true;
    drag.moved = false;
    drag.startX = e.clientX - drag.x;
    drag.startY = e.clientY - drag.y;
    fab.classList.add("dragging");
    bubble.setPointerCapture(e.pointerId);
  });

  bubble.addEventListener("pointermove", (e) => {
    if (!drag.active) return;
    const nextX = e.clientX - drag.startX;
    const nextY = e.clientY - drag.startY;
    if (Math.abs(nextX - drag.x) > 4 || Math.abs(nextY - drag.y) > 4) {
      drag.moved = true;
    }
    applyPosition(nextX, nextY);
  });

  bubble.addEventListener("pointerup", (e) => {
    if (!drag.active) return;
    drag.active = false;
    bubble.releasePointerCapture(e.pointerId);
    fab.classList.remove("dragging");
    snap();
    if (!drag.moved && e.pointerType === "touch") {
      fab.classList.toggle("open");
    }
  });

  if (canHover) {
    fab.addEventListener("mouseenter", () => {
      if (!drag.active) fab.classList.add("open");
    });
    fab.addEventListener("mouseleave", () => {
      if (!drag.active) fab.classList.remove("open");
    });
  }

  window.addEventListener("resize", () => {
    applyPosition(drag.x, drag.y);
    snap();
  });
}
</script>

</body>
</html>

